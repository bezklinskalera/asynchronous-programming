# **Всі роботи з курсу "Асинхронне програмування" Безклинська Валерія ТВ-21**

## Практичні заняття

### Практичне заняття 2 - practika2 
### Практичне заняття 3 - practika3 

___

## Практичні роботи

### Практична робота 1 - Pr1_Bezklinska
### Практична робота 2 - Pr2_Bezklinska
Ця програма на Java багатопотоково обробляє масиви випадкових чисел для пошуку простих чисел. Користувач вводить кількість масивів, діапазон випадкових чисел, і кількість елементів у масиві. Програма генерує масиви та розділяє кожен на три частини, обробляючи кожну частину в окремому потоці для пошуку простих чисел. Результати з усіх частин об'єднуються у загальний список простих чисел. За допомогою isCancelled() та isDone() перевіряється статус виконання завдань, щоб обробити скасовані чи завершені задачі. Наприкінці програма виводить знайдені прості числа та час виконання.

### Практична робота 3 - Pr3_Bezklinska
**ЗАВДАННЯ 1.** У проєкті реалізовано множення матриць двома способами: Work Stealing (динамічний розподіл завдань через Fork/Join Framework) та Work Dealing (статичний розподіл завдань через ExecutorService). Замір показав, що Work Stealing ефективніший для великих матриць завдяки динамічному балансуванню навантаження, тоді як Work Dealing може бути швидшим для невеликих задач через менші накладні витрати. Результати підтверджують, що вибір підходу залежить від розміру задачі та характеру навантаження.

**ЗАВДАННЯ 2.**
У цьому проєкті реалізовано програму, яка рахує кількість файлів у заданій користувачем директорії, що містять у своїй назві певну літеру або слово. Для вирішення задачі використано два підходи: Work Dealing та Work Stealing.

Work Dealing базується на використанні ExecutorService та пулу потоків для розподілу задач. Цей підхід є простішим у реалізації, оскільки дозволяє явно визначати, як розподіляти задачі між потоками. Кожен файл або піддиректорія обробляється незалежно, а результати підсумовуються після завершення обчислень.

Work Stealing використовує ForkJoinPool для автоматичного балансування навантаження між потоками. Завдяки цьому підходу задачі, які виконуються швидше, передаються іншим потокам, що дозволяє більш ефективно використовувати ресурси системи.
